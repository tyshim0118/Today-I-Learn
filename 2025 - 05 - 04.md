# 백준 10810
## 공 넣기 - 브론즈 3
### 문제 유형

첫째 줄에 N, M을 입력받고, M개의 줄에 걸쳐 i, j, k 세 개의 정수를 입력받고. i번 바구니부터 
j번 바구니까지 k번 번호가 적혀져 있는 공을 넣어 바구니에 들어있는 공의 번호를 출력하는 문제

### 문제 풀이 방식

N,M을 입력받아, 크기가 N인 정수 배열 arr을 생성. algorithm 헤더에 있는 fill() 함수를 이용하여
배열을 0으로 가득 채움.

1번째 반복문 (M회 반복) - 정수 i, j, k를 입력받고, 배열의 원소를 조건대로 채움.

1번째 반복문 안에 있는 2번째 반복문 (b = i-1부터 j까지 반복)을 이용해 i-1번째부터 j번째까지 배열의 원소를 
k로 변환.

반복문 블록 
```c++
for ( int a = 0 ; a < M ; a++) {
    cin >> i >> j >> k;
    for ( int b = i - 1 ; b < j ; b++ ) {
        arr[b] = k;
    }
}
```
마지막 반복문을 이용해 정수 배열 arr의 원소를 출력.

[문제 링크](https://www.acmicpc.net/submit/10810/93896232)

# 백준 10813
## 공 바꾸기 - 브론즈 2
### 문제 유형
1번부터 N번 바구니에 공이 1개씩 들어있고, 공을 바꿀 바구니 2개를 선택해 공을 서로 교환하는 작업을 M번 시행. M번 공을 바꾼 이후에 각 바구니에 들어있는 공의 번호를 출력하는 문제

### 문제 풀이 방식

N,M을 입력받아, 크기가 N인 정수 배열 arr을 생성.

1번째 반복문을 이용해 배열의 1번째 칸부터 N번째 칸까지 (0번 인덱스부터 N-1번 인덱스까지) 1 ~ N으로 채움.
```cpp
ex) int arr[5] = {1,2,3,4,5}
```
2번째 반복문을 이용, 정수 i, j를 입력받고, algorithm 헤더의 swap()함수를 이용해 arr[i-1]과
arr[j-1]을 서로 바꿈. 포인터를 이용하여 배열의 인덱스에 접근.
~~~cpp
swap( *(arr+i-1), *(arr+j-1) )
~~~
마지막 반복문을 이용해 배열의 원소를 출력.

[문제 링크](https://www.acmicpc.net/submit/10813/93897966)
