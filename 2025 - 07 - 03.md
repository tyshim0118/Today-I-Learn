# 백준 1931
## 회의실 배정 - 골드 5
### 문제 유형

한 개의 회의실이 있는데, 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만드려고 한다. 각 회의에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾는 프로그램을 작성하는 문제.

단, 회의는 한번 시작하면 중단될 수 없고, 한 회의가 끝나는 것과 동시에 다음 회의를 시작할 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수 있다.

### 문제 풀이 방식

핵심 알고리즘: 그리디 알고리즘, 정렬

우선 시작 시간이 빠른 순서대로 회의 시간을 정렬하고, 스택에 담아가며 현재 스택에 담겨있는 회의보다 관찰 중인 회의의 끝나는 시간이 빠르면 스택에 있는 회의를 pop하며 현재 관찰 중인 회의를 push하고, 현재 스택에 담겨있는 회의의 끝나는 시간보다 관찰 중인 회의의 시작시간이 느리면 일단 stack에 push하는 식으로 stack에 차곡차곡 쌓아 회의의 최대 개수를 stack의 size로 반환하도록 했다.
~~~cpp
//설명
입력: (1 4) (3 5) (0 6) (5 7) (3 8) (5 9) (6 10) (8 11)
(8 12) (2 13) (12 14)
정렬: (0 6) (1 4) (2 13) (3 5) (3 8) (5 7) (5 9) (6 10)
(8 11) (8 12) (12 14)

stack: {(0 INT_MAX)} -> (INT_MAX > 6) -> {(0 6)} -> (6 > 4)
-> {(1 4)} -> (4 < 13, 4 > 2) -> {(1 4)} -> (4 < 5, 4 > 3)
-> {(1 4)} -> (4 < 8, 4 > 3) -> {(1 4)} -> (4 < 7, 4 < 5)
-> {(1 4) (5 7)} -> .....
~~~

코드를 보자. 테스트 케이스 개수 N을 입력받고, pair<int ,int>를 타입으로 갖는 stack s와 vector v를 선언해주고, stack에는 {0,INT_MAX} pair를 push해준다. 그 다음 N회 반복 for문을 이용해 b와 e를 입력받아 {b, e} pair N개를 v에 넣어준다.

그 다음은 v를 위의 설명처럼 정렬하기 위해 sort()를 이용해 정렬해주고, iterator it가 v.begin()을 가리키게 한 다음, while문을 이용해 vector의 end()까지 반복하도록 한다.
~~~cpp
for (int i = 0; i < N; i++) {
    int b, e;
    cin >> b >> e;
    v.push_back({b, e});
}
sort(v.begin(), v.end());
~~~

if문을 통해 먼저 ((*it).second < s.top().second)이면, 즉 현재 스택에 담겨있는 회의보다 관찰 중인 회의의 끝나는 시간이 빠르면 스택에 담겨있는 회의를 pop하고 관찰 중인 회의를 스택에 push한다.
~~~cpp
if ((*it).second < s.top().second) {
    s.pop();
    s.push(*it);
}
~~~

그렇지 않고 ((*it).first >= s.top().second)이면, 즉 관찰 중인 회의의 시작 시간이 현재 스택에 담겨있는 회의의 끝나는 시간보다 뒤이면 스택에 현재 관찰 중인 회의를 바로 push한다.    
이후에 it++하여 다음으로 넘어간다.
~~~cpp
else if ((*it).first >= s.top().second) {
    s.push(*it);
}
~~~

[문제 링크](https://github.com/tyshim0118/BJ-Codes/blob/main/BJ1931.cpp)
