# 자료구조 및 프로그래밍 실습 5장 #1
## Tree Traversal

이진 트리 순회. 
이진 트리 클래스 TreeNode와 그 트리의 함수 Insert(), Preorder(), Inorder(), Postorder(),
Levelorder()를 구현한 함수이다.


```cpp
template <class T>
void Tree<T>::Insert(TreeNode<T>* &ptr, T &value) { 
    //Insert의helper함수
    //ptr은root
    if (ptr == 0) ptr = new TreeNode<T>(value);
    else if (value < ptr->data) Insert(ptr->leftChild, value);
    else if (value > ptr->data) Insert(ptr->rightChild, value);
    else cout << endl << "Duplicate value " << value << " ignored\n";
}
```
```cpp
template <class T>
void Tree<T>::Preorder(TreeNode<T> *currentNode) { 
    //Preorder의helper함수
    if (currentNode) {
        Visit(currentNode); //V
        Preorder(currentNode->leftChild); //L
        Preorder(currentNode->rightChild); //R
    }   
}
```
~~~cpp
template <class T>
void Tree<T>::Levelorder() {
    //이진 트리의 레벨 순서 순회
    queue<TreeNode<T>*> q; // 큐를 사용하자
    TreeNode<T> *currentNode = root;
    while(currentNode){
        Visit(currentNode);
        if(currentNode->leftChild) q.push(currentNode->leftChild);
        if(currentNode->rightChild) q.push(currentNode->rightChild);
        if(q.empty()) return;
        currentNode = q.front(); // 큐에서 꺼내자.
        q.pop();
    }
}
~~~

[프로그램 링크](https://github.com/tyshim0118/DataStructure-Programming/blob/main/5장%20실습%20Part%201%20.md)

# 자료구조 및 프로그래밍 실습 5장 #2
## BST

위의 구조체와 유사하나, TreeNode의 data부분 대신, key와 element의 두 멤버를 갖도록 함.
~~~cpp
template <class K, class E>
class TreeNode {
friend class BST<K,E>;
    TreeNode(K ky, E el, TreeNode<K, E> *left=0, TreeNode<K, E> *right=0) : key(ky), element(el), leftChild(left), rightChild(right) { }
private:
    TreeNode<K, E> *leftChild;
    K key;
    E element;
    TreeNode<K, E> *rightChild;
};
~~~
나머지 함수들은 거의 유사하다. 템플릿 T대신 K, E 두 개를 사용하는 점과, 트리의 노드들이 key와 element를
가진다는 점만 다르고, 원래의 TreeNode는 T타입 value로 접근했으나, 바뀐 TreeNode는 element값은 쓰지
않고 key값만 쓰기에 접근은 똑같은 방식으로 한다.

[프로그램 링크](https://github.com/tyshim0118/DataStructure-Programming/blob/main/5장%20실습%20Part%202%20.md)
