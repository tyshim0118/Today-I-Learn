# 백준 1094
## 막대기 - 실버 5
### 문제 유형
~~~
지민이는 길이가 64cm인 막대를 가지고 있다. 어느 날, 그는 길이가 Xcm인 막대가 가지고 싶어졌다.
지민이는 원래 가지고 있던 막대를 더 작은 막대로 자른다음에, 풀로 붙여서 길이가 Xcm인 막대를 만들려고 한다.

막대를 자르는 가장 쉬운 방법은 절반으로 자르는 것이다.
지민이는 아래와 같은 과정을 거쳐서 막대를 자르려고 한다.

지민이가 가지고 있는 막대의 길이를 모두 더한다. 처음에는 64cm 막대 하나만 가지고 있다.
이때, 합이 X보다 크다면, 아래와 같은 과정을 반복한다.
가지고 있는 막대 중 길이가 가장 짧은 것을 절반으로 자른다.
만약, 위에서 자른 막대의 절반 중 하나를 버리고 남아있는 막대의 길이의 합이 X보다 크거나 같다면,
위에서 자른 막대의 절반 중 하나를 버린다.
이제, 남아있는 모든 막대를 풀로 붙여서 Xcm를 만든다.
X가 주어졌을 때, 위의 과정을 거친다면, 몇 개의 막대를 풀로 붙여서 Xcm를 만들 수 있는지
구하는 프로그램을 작성하시오.
~~~
라는 문제인데, 쉽게 생각하면 주어진 X를 64 이하의 그보다 작거나 같은 2의 n제곱 수들을 어떻게 더해 나타낼 수
있고, 그 때 2의 n제곱 수는 몇 개인지를 묻는 문제이다.
~~~
ex)
64 -> 64(1)
32 -> 32(1)
23 -> 16+4+2+1(4)
58 -> 32+16+8+2(4)
~~~

### 문제 풀이 방식

int X, stick, count를 선언한다. stick은 막대기의 길이라 초기값이 64이다.
X를 입력받고, while문을 이용했다. X가 0이 아닌동안 while문은 지속된다.   
그 안의 while문은 X가 stick보다 작은 동안 stick을 2로 나누는데,
이 while문이 종료되면, X보다 작은 2의 n제곱수 중에 가장 큰 값이 stick이 된다.       
그렇게 stick이 정해지면 X에서 stick을 빼주고, count에 1을 더해준다. 이를 X가 0이 될 때까지 반복한다.
~~~cpp
while (X) {
    while (X < stick) stick /= 2;
        X -= stick;
        count++;
    }
cout << count;
~~~
~~~cpp
while(X = 20) -> 안쪽 while문으로 들어감.
while (20 < 64) -> stick = 32;
while (20 < 32) -> stick = 16;
while (20 < 16) -> while문 종료.
X -= stick -> 20 - 16 = 4 -> count = 1;

while(X = 4) -> 반복
while (4 < 16) -> stick = 8;
while (4 < 8) -> stick = 4;
while (4 < 4) -> while문 종료.
X -= stick -> 4 - 4 = 0 -> count = 2;

while(X=0) -> 종료
cout << count; -> 2 출력

~~~
[문제 링크](https://github.com/tyshim0118/BJ-Codes/blob/main/BJ1094.cpp)
