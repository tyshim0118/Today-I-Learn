# 백준 1463
## 1로 만들기 - 실버 3
### 문제 유형

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하는 프로그램을 작성하는 문제.

### 문제 풀이 방식

DP가 핵심이다. 정수 N의 최댓값이 1,000,000이므로 1에서부터 차례대로 N까지 for문을 반복하여도 시간 복잡도는 O(N)이고, 문제가 생기지 않는다. 따라서 나누는 연산을 밑에서부터 차례대로 사용하여 vector\<int> dp를 차례대로 채운다.

dp[i]를 숫자 i를 1로 만드는 최소 연산 횟수라고 하면, 해당 횟수를 구하는 경우의 수는 dp[i-1]에 +1, dp[i/2]에 +1, dp[i/3]에 +1을 하는 세 가지 경우의 수가 있고, 이 세 경우의 수 중(물론 i/2나 i/3은 i가 2나 3으로 나누어 떨어질 때) 최솟값을 구하여 dp[i]에 반영해주면 된다. 

예를 들어 dp[10]을 구한다고 해보자.
~~~cpp
dp[1] = 0;
dp[2] = dp[1] + 1 (dp[i-1]+1) = 1; 
dp[3] = dp[1] + 1 (dp[i/3]+1) = 1;
dp[4] = dp[2] + 1 (dp[i/2]+1) = 2; //dp[i-1] + 1 = 2 
dp[5] = dp[4] + 1 (dp[i-1]+1) = 3; //2,3으로 나누어떨어지지 x
dp[6] = dp[3] + 1 (dp[i/2]+1) = 2; //dp[i-1] + 1 = 4
dp[7] = dp[6] + 1 (dp[i-1]+1) = 4; //2,3으로 나누어떨어지지 x
dp[8] = dp[4] + 1 (dp[i/2]+1) = 3; //dp[i-1] + 1 = 5
dp[9] = dp[3] + 1 (dp[i/3]+1) = 2; //dp[i-1] + 1 = 4
dp[10] = dp[9] + 1 (dp[i-1]+1) = 3; //dp[i/2] + 1 = 4
//출력 : 3
~~~

이제 코드를 보자. vector\<int> dp에 push_back(0)을 두 번 하여 dp[0]과 dp[1]을 채운다. 그 다음 2부터 N-1회 반복 for문(for (int i = 2; i <= N; i++))을 이용해

먼저 dp.push_back(dp[i-1] +1)을 먼저 해주고, 

if문을 통해 우선 2로 나누어 떨어지면 dp[i/2]+1과 dp[i-1]+1 중에 더 작은 값을 dp[i]에 넣어준다.   
3으로 나누어 떨어지면 dp[i/3]+1과 dp[i-1]+1 중에 더 작은 값을 dp[i]에 넣어준다.
~~~cpp
for (int i = 2; i <= N; i++) {
    dp.push_back(dp[i - 1] + 1);  // 1을 빼는 연산
    if (i % 2 == 0) dp[i] = min(dp[i], dp[i / 2] + 1);
    if (i % 3 == 0) dp[i] = min(dp[i], dp[i / 3] + 1);
}
~~~

N번까지 반복하고 나면, dp[N]을 출력해준다.

[문제 링크](https://github.com/tyshim0118/BJ-Codes/blob/main/*BJ1463.cpp)
