# 백준 1978
## 소수 찾기 - 브론즈 2
### 문제 유형

N개의 정수를 입력받아 소수가 몇 개인지 출력하는 프로그램을 작성하는 문제

### 문제 풀이 방식

소수는 1과 자기 자신만으로만 나누어 떨어지는 수이다. 따라서, 다른 수로 나눴을 때도 나머지가 0이라면, 이는 소수가 아니라는 것이다. 일단 N을 입력받고, for문을 이용해 N번 반복한다.    
for문 내에서는 prime을 입력받고, 이중 for문을 이용해 2부터 prime(자기 자신)까지 반복한다.   
이중 반복문 내에서는 우선 if (prime이 만약 j와 같아진다면) prime이 1빼고 다른 수로는 나누어떨어지지 않았다는 뜻이므로, 소수임이 확인되고, 따라서 res에 1을 더해준다.   
대부분의 경우 첫 if문은 통과할텐데, 첫 if문을 통과하면 prime을 j로 나눈 나머지를 구해 나누어떨어지지 않으면 j에 1을 더해 계속 관찰하고, 나누어 떨어졌다는 것은 1과 자기자신 외에 다른 수로도 나누어떨어진다는 것이므로 안의 for문을 break하여 다음 정수를 테스트한다.
바깥 for문이 모두 끝나면 res를 출력하고 프로그램을 종료한다.

~~~cpp
int main() {
    int N, res = 0;
    cin >> N;
    for (int i = 0; i < N; i++) {
        int prime;
        cin >> prime;
        for (int j = 2; j <= prime; j++) {
            if (prime == j) res++;
            if (prime % j == 0) break;
        }
    }
    cout << res;
}
~~~

[문제 링크](https://github.com/tyshim0118/BJ-Codes/blob/main/BJ1978.cpp)
