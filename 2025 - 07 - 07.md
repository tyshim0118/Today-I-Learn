# 백준 1018
## 체스판 다시 칠하기 - 실버 4
### 문제 유형

주어진 M×N 크기의 보드를 8×8 크기로 잘라낸 후, 검은색과 흰색이 번갈아가면서 나오는 체스판으로 만들기 위해서는 몇 개의 정사각형을 다시 칠해야하는 지를 구하고, 그 최소 개수를 구하는 프로그램을 작성하는 문제.

### 문제 풀이 방식

int pick(string s[])을 보자. 정수 wres와 bres는 각각 첫 번째 칸이 'W'일 때 색칠할 칸의 수와 'B'일 때 색칠할 칸의 수이다.    

8회 반복하는 이중 for문 안에서 i+j가 홀수이면 s[i][j]는 첫 번째 칸과 색이 달라야한다. 따라서 s[i][j]가 'B'이면 첫번째 칸이 'B'일 때 칠해야 하므로 if문을 통해 bres를 1 늘려준다.
'B'가 아닌 'W'라면 첫번째 칸이 'W'일 때 칠해야 하므로 wres를 1 늘려준다.
~~~cpp
조건: if s[i][j] == 'B'

첫번째 칸이 'B' -> s[0][1] (0+1 = 1 -> 홀수)은 'W'여야함.
-> s[0][1]이 'B'면 칠함 -> bres++ (if)
첫번째 칸이 'W' -> s[0][1] (0+1 = 1)은 'B'여야함.
-> s[0][1]이 'W'면 칠함 -> wres++ (else)
~~~

i+j가 짝수이면 s[i][j]는 첫 번째 칸과 색이 같아야한다. 따라서 s[i][j]가 'B'이면 첫 번째 칸이 'B'가 아닐 때, 즉 'W'일 때 칠해야 하므로 if문을 통해 wres를 1 늘려준다.   
'W'라면 첫번째 칸이 'B'일 때 칠해야 하므로 bres를 1 늘려준다.
~~~cpp
조건: if s[i][j] == 'B'

첫번째 칸이 'B' -> s[1][1] (1+1 = 2)은 'B'여야함.
-> s[1][1]이 'W'면 칠함 -> bres++ (else)
첫번째 칸이 'W' -> s[1][1] (1+1 = 2)은 'W'여야함.
-> s[1][1]이 'B'면 칠함 -> wres++ (if)
~~~
마지막에 삼항연산자를 통해 더 작은 res를 리턴한다.

~~~cpp
int pick(string s[]) {
    int bres = 0, wres = 0;
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            if ((i + j) % 2) {
                if (s[i][j] == 'B') bres++;
                else wres++;
            } else {
                if (s[i][j] == 'B') wres++;
                else bres++;
            }
        }
    }
    return (wres<bres) ? wres : bres;
}
~~~

이제 main()함수를 보자. 먼저 정수 N,M 순서로 입력받고, N칸 string 배열 board를 선언한다. N회 반복 for문을 이용해 board의 각 칸을 채우고, 

이중 for문(i = 0 ~ M - 7, j = 0 ~ N - 7)을 통해 8칸 배열 line을 선언하고,    
안에 하나의 8회 반복 for문(k)을 통해 line[k]에 board[j+k].substr(i,8), 즉 board의 j+k번째 인덱스에 해당하는 string에서 i번째 인덱스부터 i+8까지를 떼서 넣는다. 이를 8번 반복하여 line[8]을 모두 채우고, line을 그대로 pick()에 넣고, 그 값을 정수 p에 받는다. 그 p값이 현재까지 조사했던 res보다 적으면 p값을 res에 넣는다. 

~~~cpp
M=9, N=9이면, 처음에 line[8]에는 원래 체스판의 [0][0] ~ [7][7]이 들어가고,
그 다음에는 [1][0] ~ [8][7]이, 그 다음엔 [0][1] ~ [7][8]이,
그 다음엔 [1][1] ~ [8][8]이 들어간다. 각 line의 p값 중 가장 적은 값이 res가 된다.
~~~

이렇게 모두 조사하여 구한 가장 적은 p값을 출력하여 종료한다.

~~~cpp
for (int i = 0; i < M - 7; i++) {
    for (int j = 0; j < N - 7; j++) {
        string line[8];
        for (int k = 0; k < 8; k++) {
            line[k] = board[j + k].substr(i, 8);
        }
        int p = pick(line);
        if (res > p) res = p;
    }
}
~~~

[문제 링크](https://github.com/tyshim0118/BJ-Codes/blob/main/BJ1018.cpp)
