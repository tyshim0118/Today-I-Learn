# 백준 1018
## 체스판 다시 칠하기 - 실버 4
### 문제 유형

주어진 M×N 크기의 보드를 8×8 크기로 잘라낸 후, 검은색과 흰색이 번갈아가면서 나오는 체스판으로 만들기 위해서는 몇 개의 정사각형을 다시 칠해야하는 지를 구하고, 그 최소 개수를 구하는 프로그램을 작성하는 문제.

### 문제 풀이 방식

int pick(string s[])을 보자. 정수 wres와 bres는 각각 첫 번째 칸이 'W'일 때 색칠할 칸의 수와 'B'일 때 색칠할 칸의 수이다.    

8회 반복하는 이중 for문 안에서 i+j가 홀수이면 s[i][j]는 첫 번째 칸과 색이 달라야한다. 따라서 s[i][j]가 'B'이면 첫번째 칸이 'B'일 때 칠해야 하므로 if문을 통해 bres를 1 늘려준다.
'B'가 아닌 'W'라면 첫번째 칸이 'W'일 때 칠해야 하므로 wres를 1 늘려준다.
~~~cpp
조건: if s[i][j] == 'B'

첫번째 칸이 'B' -> s[0][1] (0+1 = 1 -> 홀수)은 'W'여야함.
-> s[0][1]이 'B'면 칠함 -> bres++ (if)
첫번째 칸이 'W' -> s[0][1] (0+1 = 1)은 'B'여야함.
-> s[0][1]이 'W'면 칠함 -> wres++ (else)
~~~

i+j가 짝수이면 s[i][j]는 첫 번째 칸과 색이 같아야한다. 따라서 s[i][j]가 'B'이면 첫 번째 칸이 'B'가 아닐 때, 즉 'W'일 때 칠해야 하므로 if문을 통해 wres를 1 늘려준다.   
'W'라면 첫번째 칸이 'B'일 때 칠해야 하므로 bres를 1 늘려준다.
~~~cpp
조건: if s[i][j] == 'B'

첫번째 칸이 'B' -> s[1][1] (1+1 = 2)은 'B'여야함.
-> s[1][1]이 'W'면 칠함 -> bres++ (else)
첫번째 칸이 'W' -> s[1][1] (1+1 = 2)은 'W'여야함.
-> s[1][1]이 'B'면 칠함 -> wres++ (if)
~~~
마지막에 삼항연산자를 통해 더 작은 res를 리턴한다.

~~~cpp
int pick(string s[]) {
    int bres = 0, wres = 0;
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            if ((i + j) % 2) {
                if (s[i][j] == 'B') bres++;
                else wres++;
            } else {
                if (s[i][j] == 'B') wres++;
                else bres++;
            }
        }
    }
    return (wres<bres) ? wres : bres;
}
~~~

[문제 링크]()
