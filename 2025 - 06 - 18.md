# 백준 15829
## Hashing - 브론즈 2
### 문제 유형

 
$\[H = \sum_{i=0}^{l-1}{a_ir^i} \mod M\] $

보통 r과 M은 서로소인 숫자로 정하는 것이 일반적이다. 우리가 직접 정하라고 하면 힘들테니까 r의 값은 26보다 큰 소수인 31로 하고 M의 값은 1234567891(놀랍게도 소수이다!!)로 하자.

위의 수식을 통해 주어진 문자열의 해시 값을 계산하는 프로그램을 작성하는 문제.


### 문제 풀이 방식

우선 모듈러 연산이라는 연산 방법에 대해 알아야 한다. 모듈러 연산은 나머지에 관해 계산을 정의하는 방법으로,
1. ((a % M) + (b % M)) % M = (a+b) % M
2. ((a % M) - (b % M)) % M = (a-b) % M
3. ((a % M) * (b % M)) % M = (a*b) % M
   이다.

우린 여기서 3번째 연산을 주로 사용할 것이다.   

우선 L은 문자열 개수, hash는 해싱한 총 합, modulo는 1부터 시작해서 31씩 곱한 수를 M으로 나눈 값을 의미한다. str은 입력받은 문자열이다.

for문을 보도록 하자. hash에 (modulo * str[i] - 'a' + 1 )을 1234567891로 나눈 나머지를 더하고, 해당값이 오버플로나지 않고, 해시값은 0~1234567890, 즉 mod 1234567891 값이어야 하기 때문에 마지막에 hash 계산 후 % 1234567891 계산을 해주어야 한다.   
hash 계산을 끝마치고 나면, modulo를 구하는데,
modulo도 어차피 pow(31,i)값을 1234567891로 나눈 값이므로, 똑같이 3번 모듈러 연산을 이용해
modulo값을 계속해서 구해준다. 이를 i가 L이 될 때까지 총 L번 반복하여 주면 해시값을 구할 수 있다.

~~~cpp
//모듈러 값 연산

1234567891 = ㅁ라고 하자.

31 % ㅁ = ((31^0 % ㅁ) * (31 % ㅁ)) % ㅁ;
31^2 % ㅁ = ((31^1 % ㅁ) * (31 % ㅁ)) % ㅁ;
31^3 % ㅁ = ((31^2 % ㅁ) * (31 % ㅁ)) % ㅁ;

따라서 맨 처음 31^0 = modulo라고 한다면, 31 % ㅁ는 항상 31이므로
modulo = (modulo * 31 ) % 1234567891을 반복하면 계속해서 pow(31,i)값을 1234567891로
나는 나머지 값을 구할 수 있고, 이를 str[i]를 정수로 변환한 값과 곱하고 나누는 과정을 통해 문제를 해결했다.
~~~

~~~cpp
//코드 (for문)
for (int i = 0; i < L; i++) {
    hash = (hash + ((modulo * (str[i] - 'a' + 1)) % 1234567891)) % 1234567891;
    modulo = (modulo * 31) % 1234567891;
}
~~~

[문제 링크](https://github.com/tyshim0118/BJ-Codes/blob/main/*BJ15829.cpp)
