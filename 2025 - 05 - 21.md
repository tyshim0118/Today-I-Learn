# 백준 2292
## 벌집 - 브론즈 2
### 문제 유형

링크를 참조하자. 벌집 모양 그림이 있다. 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 
주소로 매길 수 있다.   
숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지를
계산하는 프로그램을 작성하는 문제.

### 문제 풀이 방식

1개의 방만 지나는 경우는 1. 2개의 방을 지나는 경우는 2~7. 3개면 8~19. 4개면 20~37이다. 규칙성이 느껴지지
않는가? 방의 개수(이를 i라 하자)가 하나 늘어날 때마다 그 개수만큼의 방을 지나는 경우는 6*i개 씩 늘어난다.   
따라서, 이를 이용하면 쉽게 풀 수 있을거라 생각했다.

먼저 int타입 변수 cur, N, ring을 선언한다.    
cur은 위에서 방을 지나는 경우의 가장 큰 수를 나타낸다. 방을 1개만 지날 때는 1, 2개일 땐 7, 3개일 땐 19가 
된다. 따라서 초기값은 1로 한다.   
N은 입력받은 방의 번호이고, ring은 방의 개수를 의미한다. 그림을 보면 방을 지나는 경우의 개수에 따라 육각형을
그렸을 때 층별로 나뉘기 때문에 ring으로 표시했다. 초기값은 0이다.

while문 안이 핵심이다. cur이 N보다 작을 때, cur에 6*ring을 더해주고, ring에 1을 더해준다. 이를 cur이
N보다 크거나 같을 때까지 반복하면 ring의 개수, 즉 몇 개의 방을 지나는지를 구할 수 있다.
~~~cpp
    while (cur < N) {
        cur += 6 * ring;
        ring++;
    }
~~~

하지만, 이렇게 하면 cur이 1일 때, ring은 0이 된다. 따라서 이러한 오류를 막기 위해, if문을 사용하여 예외를
두었다. (cur==1)일 때, 1을 출력하고 프로그램을 종료한다. 그렇지 않을 때는 ring을 출력한다.
~~~cpp
if (cur == 1) {cout << 1; return 0;}
~~~

[문제 링크](https://github.com/tyshim0118/BJ-Codes/blob/main/BJ2292.cpp)

# 백준 문제 번호
## 문제 제목 - 문제 티어
### 문제 유형

문제의 유형, 무슨 문제인지 서술.

### 문제 풀이 방식

문제를 내가 어떻게 해결하였는지, 어떤 언어의 어떤 문법을 사용하였는지 서술

[문제 링크]()
