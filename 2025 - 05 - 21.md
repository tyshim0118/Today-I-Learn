# 백준 2292
## 벌집 - 브론즈 2
### 문제 유형

링크를 참조하자. 벌집 모양 그림이 있다. 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 
주소로 매길 수 있다.   
숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지를
계산하는 프로그램을 작성하는 문제.

### 문제 풀이 방식

1개의 방만 지나는 경우는 1. 2개의 방을 지나는 경우는 2~7. 3개면 8~19. 4개면 20~37이다. 규칙성이 느껴지지
않는가? 방의 개수(이를 i라 하자)가 하나 늘어날 때마다 그 개수만큼의 방을 지나는 경우는 6*i개 씩 늘어난다.   
따라서, 이를 이용하면 쉽게 풀 수 있을거라 생각했다.

먼저 int타입 변수 cur, N, ring을 선언한다.    
cur은 위에서 방을 지나는 경우의 가장 큰 수를 나타낸다. 방을 1개만 지날 때는 1, 2개일 땐 7, 3개일 땐 19가 
된다. 따라서 초기값은 1로 한다.   
N은 입력받은 방의 번호이고, ring은 방의 개수를 의미한다. 그림을 보면 방을 지나는 경우의 개수에 따라 육각형을
그렸을 때 층별로 나뉘기 때문에 ring으로 표시했다. 초기값은 0이다.

while문 안이 핵심이다. cur이 N보다 작을 때, cur에 6*ring을 더해주고, ring에 1을 더해준다. 이를 cur이
N보다 크거나 같을 때까지 반복하면 ring의 개수, 즉 몇 개의 방을 지나는지를 구할 수 있다.
~~~cpp
    while (cur < N) {
        cur += 6 * ring;
        ring++;
    }
~~~

하지만, 이렇게 하면 cur이 1일 때, ring은 0이 된다. 따라서 이러한 오류를 막기 위해, if문을 사용하여 예외를
두었다. (cur==1)일 때, 1을 출력하고 프로그램을 종료한다. 그렇지 않을 때는 ring을 출력한다.
~~~cpp
if (cur == 1) {cout << 1; return 0;}
~~~

[문제 링크](https://github.com/tyshim0118/BJ-Codes/blob/main/BJ2292.cpp)

# 백준 1193
## 분수찾기 - 실버 5
### 문제 유형

무한히 큰 배열에 다음과 같이 분수들이 적혀있다.
~~~
1/1 1/2 1/3 1/4 1/5 ...
2/1 2/2 2/3 2/4 ... ... 
3/1 3/2 3/3 ... ... ...
... ... ...
~~~
이와같이 나열된 분수들을 1/1 -> 1/2 -> 2/1 -> 3/1 -> 2/2 -> ...과 같은 지그재그 순서로 차례대로 1,2,3,4,5,...번 분수라고 하자. X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하는 문제.

### 문제 풀이 방식

우선, 기준을 분모로 잡고 시작했다. 무슨 말이냐면, 지그재그 순서가 아니라 대각선 순서로 1/1 -> 2/1 -> 1/2 -> 3/1 -> 2/2 -> 1/3 -> 4/1 -> ...으로 문제를 푼 뒤, 마지막에 지그재그로 바꿀 수 있는 스위치를 설정해서 프로그램을 구현하였다.   
우선 바꾼 순서를 보면, 분자가 1이 되고, 분모가 1씩 늘어나는 구간, 즉 1/1, 1/2, 1/3, 1/4 등의 순서는 1번, 3번, 6번, 10번으로, 0부터 시작해서 1, 2, 3, 4를 더한 번호 i의 분수는 반드시 1/i가 된다는 규칙을 만들 수 있다. 이를 바탕으로 프로그램을 구현해보자.

int 타입 i는 분수의 번호이다. X는 입력받은 수. deno는 분모, nume는 분자. oddSwitch는 이따 설명하도록 하겠다.
각각 i는 맨 처음에 0번 분수가 있다고 가정하고, 1,2,3,4를 차례대로 더해주기 위해(1,3,6,10으로 늘어남)
초기값을 0으로 잡았다.
deno는 i와 비슷하게 1,2,3,4로 점점 늘어나기 때문에 초기값을 0으로 잡았다. nume는 분자인데, 처음에 기본으로 순서를 정할때는 계속 1이다가 마지막에 정확한 위치를 찾을 때만 변환해주면 되므로 초기값을 1로 잡았다.

1번 while문은 i가 X보다 작으면, deno에 1을 더해주고, i에 deno를 더해준다. 그러면 X번째 분수의 대각선 위치를 얻을 수 있다.
~~~cpp
while (i < X) {
        deno++;
        i += deno;
    }
~~~
if문을 보면 deno%2가 0이면 oddSwitch가 0으로 바뀌는데, 이 oddSwitch는 출력 시에 deno가 홀수이면 1이 되어 nume/deno를 출력하고, 짝수이면 deno/nume를 출력하도록 했다. 마지막의 if-else문에 나와있다.

그 다음 while문은 이제 한 대각선(분모+분자가 같은)에서 정확한 위치를 찾는 과정이다. i가 X보다 클 때(i가 그 라인의 최댓값이므로) i와 deno는 1 줄이고, nume는 1 늘린다. 이를 반복해서 i가 X와 같아지면 deno와 nume의값이 정해진다.

마지막 if-else문은 다시 원래대로 지그재그의 형태로 수정하는 과정이다. 라인의 위치는 그대로 두고, 분자와 분모의 순서만 바꾸면 되기 때문에 이런 식으로 표현했다.

[문제 링크](https://github.com/tyshim0118/BJ-Codes/blob/main/BJ1193.cpp)
