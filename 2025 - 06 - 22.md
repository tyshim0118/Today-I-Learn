# 백준 11866
## 요세푸스 문제 0 - 실버 4
### 문제 유형

1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다.   
이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다.    
예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.   

N과 K가 주어졌을 때 (N,K) 요세푸스 순열을 구하는 프로그램을 작성하는 문제.

### 문제 풀이 방식

문제를 다 풀고 나니 큐를 사용하면 더 쉬웠을 것 같다. 그냥 큐에서 꺼내서 넣고 꺼내서 넣고를 K번 반복하여 큐가 빌 때까지 하면 되는 문제이긴 하다.

내가 푼 방법은 배열을 이용했다.

우선 N,K를 입력받고, N+1칸 int 벡터 v를 만들어 모두 0으로 채운다. v[0]은 사용하지 않을 것이므로 먼저 1로 바꿔주고, int index=0을 선언한다.    

가장 먼저 for문은 N번 반복하여 수를 꺼내게 하는 반복문이다. N회 반복하고, 모든 과정은 이 for문 내에서 이루어진다.   

for문 내부를 보면 먼저 count 변수를 0으로 선언해주고, count가 K-1보다 작을 때, (즉 K-1번 반복하는) v[index]에 접근하여 값이 0이라면 count를 1 늘려주고, 다음 index로 넘어간다. 이 때 index가 N을 넘어가면 안되므로, 항상 index에 나머지 연산을 해주어야한다.  
여기서 v의 원소가 1이면 출력한 수임을 나타내고, 0이면 아직 출력하지 않았음을 나타낸 다는 것을 알 수 있다. 암튼, 출력하지 않은 수만 찾아야하므로 if문을 이용해 v[index]가 0일 때만 count를 증가시킨다.
~~~cpp
        int count = 0;
        while (count < K - 1) {
            if (v[index %= N + 1] == 0) count++;
            index++;
        }
~~~

그러나 이렇게 해도 만약 v[index]바로 다음이 이미 출력한 수라면 오류가 생기므로, 다음 while문을 이용해 v[index]가 0인 칸을 찾을 때까지 index를 늘려 찾는다.   
바꿀 칸을 찾았으면 1로 바꿔주고, index를 출력한다. 
~~~cpp
        while (v[index %= N + 1]) index++;
        v[index %= N + 1] = 1;
        cout << index;
~~~

마지막 if-else문은 문제 출력에 맞게 ", "와 ">"를 출력하기 위한 문장이다.
~~~cpp
 if (i < N - 1) cout << ", ";
        else cout << ">";
~~~

[문제 링크](https://github.com/tyshim0118/BJ-Codes/blob/main/BJ11866.cpp)
