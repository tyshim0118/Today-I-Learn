# 백준 1874
## 스택 수열 - 실버 2
### 문제 유형

스택에 1부터 n까지의 수를 push, pop 연산을 수행해 하나의 수열을 만들 수 있다. 이 때, 스택에 push하는 순서는
반드시 오름차순을 지키도록 하다고 하자. 임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들수 있는지,
있다면 어떤 순서로 연산을 수행해야 하는지 계산하는 프로그램을 작성하는 문제.

### 문제 풀이 방식

stack을 실제로 구현하기 위해 stack 헤더를 사용하였다.   
stack 헤더에는 여러 연산이 있지만, 나는 push(),pop(),top()을 주로 사용하였다. push(int)는 스택에
int값을 넣는 연산이고, pop()은 top에 있는 원소를 빼는 연산, top()은 top에 있는 원소를 반환하는 연산이다.

stack<int >로 int 타입 stack을 만든다. str은
string 타입으로 결과를 모두 str에 넣어 한 번에 출력하고자 했다.   
N은 수열의 크기로, 가장 먼저 입력받는다.   
seq[N]은 배열을 통해 미리 수열을 입력받기 위해 사용하였다. for문을 이용해 먼저 seq에 원소를 삽입했다.
~~~cpp
for (int i = 0; i < N; i++) {
    cin >> t;
    seq[i] = t;
}
~~~
prev는 초기값이 0으로 나중에 스택 연산을 시행할 때 전에 스택에 마지막으로 push된 수가 무엇인지 기록한다.
p는 +, m은 -이다.   
range-based for문을 통해 seq 내부의 원소를 순차적으로 e에 넣어 연산을 시행한다.   
가장 첫번째 if문은 stack이 비어있으면 top()을 사용할 수 없기에 이를 방지하고자 넣은 연산이다. 가장 처음에 stack이
만들어졌을 때만 작동한다. ~~근데 생각해보니 굳이 for문에 넣지 않고 처음부터 s에 0을 push했으면 됐을 거 같다는 
생각이 든다.~~   

다음 if문과 그 밑에 if문을 함께 보자. 이것이 가장 핵심 코드로, 수열이 들어왔을 때, s.top()과 e가 같으면 
그냥 출력하면 되기에 if문을 건너뛴다. 만약 s.top()이 e보다 작으면 top과 e가 맞춰질 때까지 prev+1부터
e까지 모든 값을 stack에 push해주고, 이러면 prev 다음 수부터 e까지 stack에 차례대로 투입된다.
만약 s.top()이 e보다 크면 수열을 stack을 통해 만들 수 없으므로 "NO"를 출력하고 프로그램을 종료한다.   
그 이후에 top을 pop하면 된다. if문 내의 연산이 수행된 후에는 top과 e가 반드시 같기에, pop을 하면 e가
stack에서 pop됨을 알 수 있다.   
마지막으로 "prev가 e보다 작을 때"라는 조건은 prev는 마지막으로 push된 수이고, e가 prev보다 작다는 것은
push가 일어나지 않고 바로 pop이 일어났다는 것이고, 크면 e가 마지막으로 push된 수이므로 prev를 e로 바꿔주는
것이다.

~~~cpp
for (int e : seq) {
    if (!s.size()) {
        s.push(0);
    }
    if (s.top() > e) {cout << "NO"; return 0; }
    if (s.top() < e) {
        for (int j = prev+1; j <= e; j++) {
            s.push(j);
            str.append(p);
        }
    }
s.pop();
str.append(m);
~~~

글로 보는 것보단 작동방식을 이렇게 보면 더 쉬울 것 같다.
~~~cpp
입력(N=8): 4 3 6 8 7 5 2 1
먼저 top은 현재 0이고, prev도 0이다. e는 4이다. 첫 if문은 통과하고, 
두 번째 if문을 만족하므로 반복문을 통해 prev+1=1부터 4까지 stack에 넣는다.
e가 prev보다 크므로 prev를 4로 바꿔준다.
현재 stack : [ 1 2 3 4 <- top ] (++++)
-> 4 pop [ 1 2 3 <- top ] (++++-)
//stack 표시 0 생략, top: 3, prev: 4

다음은 3이 들어왔다. top이 3, e도 3이므로 두 if문을 모두 통과하고 3이 pop된다. prev는 바뀌지 않는다.
3 pop [ 1 2 <- top ] (++++--)
//top: 2, prev: 4

6이 들어왔다. 첫 if문은 통과하고, 두 번째 if문을 만족하므로 prev+1 = 5부터 6까지 stack에 push,
6을 pop한다. prev보다 6이 크므로, prev를 6으로 바꿔준다.
[ 1 2 5 6 <- top ] (++++--++) 
-> 6 pop [ 1 2 5 <- top ] (++++--++-)
//top: 5, prev: 6

8이 들어왔으므로 7부터 8까지 stack에 push, 8을 pop한다. prev도 8이 된다.
[ 1 2 5 7 8 <- top ] (++++--++-++) 
-> 8 pop [ 1 2 5 7 <- top ] (++++--++-++-)
//top : 7, prev: 8

stack에  1 2 5 7이 들어있고, 수열도 차례대로 7 5 2 1이다. 4번 모두 if문을 통과하고 pop되며, prev는
바뀌지 않는다.
[ 0 <- top ] (++++--++-++-----) <- 출력 및 종료
~~~

[문제 링크](https://github.com/tyshim0118/BJ-Codes/blob/main/BJ1874.cpp)
