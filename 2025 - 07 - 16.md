# 백준 11047 
## 동전 0 - 실버 4
### 문제 유형

N종류의 동전이 있고, 동전을 적절히 사용하여 그 가치의 합을 K로 만드려 한다. 이 때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하는 문제.

첫째 줄에 N과 K가 주어지고, 둘째 줄부터 N개의 줄에 동전의 가치가 오름차순으로 주어진다.
### 문제 풀이 방식

보통 동전의 최소 개수를 구할 때는 가치가 큰 동전부터 주어진 K에 몫과 나머지 연산을 실행하여 구하므로, 이번에도 그렇게 하기로 했다. 

동전의 가치가 오름차순으로 주어지므로, stack을 이용하면 LIFO이므로 마지막에 들어온 가장 가치가 큰 동전부터 이용할 수 있다고 생각했다.

int stack s를 선언하고, N,K,coins를 선언한다. coins는 출력을 위한 동전의 개수를 의미하므로, 초기값을 0으로 정의한다. 

N과 K를 입력받은 다음, N회 반복 for문을 이용해 int coinValue를 입력받고, 이를 s에 push하였다. 입력은 오름차순으로 주어지므로, for문이 끝나고 나면 s에서는 순차적으로 가장 가치가 큰 동전을 pop할 수 있다.

~~~cpp
for (int i = 0; i < N; i++) {
    int coinValue;
    cin >> coinValue;
    s.push(coinValue);
}
~~~

while문을 통해 K가 0이 아닌동안, coins에 K/s.top()을 더해준다. 그 다음엔 K를 s.top()으로 나눈 나머지를 K에 덮어씌우고, s에 pop을 해준다. 
~~~cpp
while (K) {
    coins += (K/s.top());
    K %= s.top();
    s.pop();        
}
~~~


이를 예시를 들어 보면, 
~~~cpp
//입력 : 10 4200 / 1 5 10 50 100 500 1000 5000 10000 50000
N = 10, K = 4200;
s : [ 50000 10000 5000 1000 500 100 50 10 5 1]
1. 4200 / 50000 = 0(int) -> coins = 0 ->  K = 4200 % 50000 = 4200
 -> s.pop();
2. 4200 / 10000 = 0(int) -> coins = 0 -> K = 4200 % 10000 = 4200
-> s.pop();
3. 4200 / 5000 = 0(int) -> coins = 0 -> K = 4200 % 5000 = 4200
-> s.pop();
4. 4200 / 1000 = 4(int) -> coins = 4 -> K = 4200 % 1000 = 200
-> s.pop();
5. 200 / 500 = 0(int) -> coins = 4 -> K = 200 % 500 = 200
-> s.pop();
6. 200 / 100 = 2(int) -> coins = 6 -> K = 200 % 100 = 0
-> s.pop();
7. 종료
~~~
coins를 출력하면 프로그램이 종료된다.

[문제 링크](https://github.com/tyshim0118/BJ-Codes/blob/main/BJ11047.cpp)
